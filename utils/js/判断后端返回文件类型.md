```ts
/**
 * 根据响应头判断数据类型
 * @param {Response} response - Fetch API返回的Response对象
 * @returns {string} - 数据类型：'json' | 'file' | 'text' | 'stream' | 'other'
 */
function getResponseTypeByHeader(response) {
    const contentType = response.headers.get('content-type');
    
    if (!contentType) {
        return 'other';
    }
    
    // JSON类型
    if (contentType.includes('application/json')) {
        return 'json';
    }
    
    // 文件类型
    const fileTypes = [
        'application/pdf',
        'application/msword',
        'application/vnd.ms-excel',
        'application/vnd.ms-powerpoint',
        'application/zip',
        'application/octet-stream',
        'image/',
        'audio/',
        'video/'
    ];
    
    if (fileTypes.some(type => contentType.includes(type))) {
        return 'file';
    }
    
    // 文本类型
    if (contentType.includes('text/')) {
        return 'text';
    }
    
    // 流类型
    if (contentType.includes('stream') || contentType.includes('chunked')) {
        return 'stream';
    }
    
    return 'other';
}
```

```ts
/**
 * 尝试解析响应数据，判断实际类型
 * @param {Response} response - Fetch API返回的Response对象
 * @returns {Promise<Object>} - 包含类型和数据的对象
 */
async function parseResponse(response) {
    const typeByHeader = getResponseTypeByHeader(response);
    let data, actualType = typeByHeader;
    
    try {
        switch (typeByHeader) {
            case 'json':
                try {
                    data = await response.json();
                    actualType = 'json';
                } catch (e) {
                    // 虽然Content-Type是json，但实际可能是文本
                    data = await response.text();
                    actualType = 'text';
                }
                break;
                
            case 'file':
                data = await response.blob();
                actualType = 'file';
                break;
                
            case 'text':
                data = await response.text();
                // 检查文本是否是JSON格式
                try {
                    const jsonData = JSON.parse(data);
                    data = jsonData;
                    actualType = 'json';
                } catch (e) {
                    actualType = 'text';
                }
                break;
                
            case 'stream':
                data = response.body; // ReadableStream
                actualType = 'stream';
                break;
                
            default:
                // 尝试多种解析方式
                try {
                    data = await response.json();
                    actualType = 'json';
                } catch (e1) {
                    try {
                        data = await response.text();
                        actualType = 'text';
                    } catch (e2) {
                        data = await response.blob();
                        actualType = 'file';
                    }
                }
        }
    } catch (error) {
        console.error('解析响应失败:', error);
        data = null;
        actualType = 'error';
    }
    
    return {
        type: actualType,
        data: data,
        originalType: typeByHeader,
        response: response
    };
}
```

```ts
/**
 * 处理文件下载响应
 * @param {Object} result - parseResponse返回的结果
 * @param {string} defaultFileName - 默认文件名
 */
function handleFileDownload(result, defaultFileName = 'download') {
    if (result.type !== 'file') {
        throw new Error('不是文件类型的响应');
    }
    
    const blob = result.data;
    const response = result.response;
    
    // 从响应头获取文件名
    let fileName = defaultFileName;
    const contentDisposition = response.headers.get('content-disposition');
    
    if (contentDisposition) {
        const match = contentDisposition.match(/filename="?([^"]+)"?/i);
        if (match && match[1]) {
            fileName = decodeURIComponent(match[1]);
        }
    }
    
    // 创建下载链接
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    
    // 清理
    window.URL.revokeObjectURL(url);
    document.body.removeChild(a);
    
    return { fileName, blob };
}
```