```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas 声音跳动动画</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a2e;
            overflow: hidden;
        }
        canvas {
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 128, 255, 0.3);
        }
    </style>
</head>
<body>
    <canvas id="audioVisualizer"></canvas>

    <script>
        // 获取Canvas和上下文
        const canvas = document.getElementById('audioVisualizer');
        const ctx = canvas.getContext('2d');

        // 设置Canvas尺寸
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 400;
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // 频谱柱参数
        const barCount = 50; // 频谱柱数量
        const barWidth = CANVAS_WIDTH / barCount - 2; // 柱宽度（留间距）
        const barGap = 2; // 柱间距
        let barHeights = new Array(barCount).fill(0); // 存储每个柱的高度
        let targetHeights = new Array(barCount).fill(0); // 目标高度（模拟声音波动）

        // 颜色渐变（从青色到紫色）
        const gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
        gradient.addColorStop(0, '#00f5d4');
        gradient.addColorStop(0.5, '#3a86ff');
        gradient.addColorStop(1, '#8338ec');

        // 随机更新目标高度（模拟声音节奏）
        function updateTargetHeights() {
            for (let i = 0; i < barCount; i++) {
                // 随机生成目标高度，加入相邻柱的关联（模拟真实频谱的连续性）
                const randomHeight = Math.random() * (CANVAS_HEIGHT - 40) + 10;
                const neighborInfluence = (i > 0 ? targetHeights[i-1] : randomHeight) * 0.3;
                targetHeights[i] = randomHeight * 0.7 + neighborInfluence;
                
                // 偶尔生成大峰值（模拟重低音）
                if (Math.random() < 0.08) {
                    targetHeights[i] = CANVAS_HEIGHT * 0.8;
                }
            }
        }

        // 平滑过渡到目标高度
        function updateBarHeights() {
            for (let i = 0; i < barCount; i++) {
                // 缓动公式：当前值 += (目标值 - 当前值) * 阻尼
                const easeFactor = 0.12; // 缓动系数（越小越平滑）
                barHeights[i] += (targetHeights[i] - barHeights[i]) * easeFactor;
                
                // 加入微小的重力回落
                if (barHeights[i] > 0) {
                    barHeights[i] = Math.max(0, barHeights[i] - 0.5);
                }
            }
        }

        // 绘制频谱柱
        function drawBars() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            for (let i = 0; i < barCount; i++) {
                const x = i * (barWidth + barGap);
                const y = CANVAS_HEIGHT - barHeights[i]; // 从底部开始绘制
                const height = barHeights[i];

                // 绘制主柱体
                ctx.fillStyle = gradient;
                ctx.fillRect(x, y, barWidth, height);

                // 绘制柱体高光（顶部小矩形）
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.fillRect(x, y, barWidth, Math.max(2, height * 0.1));

                // 绘制柱体阴影（增加立体感）
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(x, y + height, barWidth, 4);
            }
        }

        // 动画循环
        function animate() {
            // 随机更新目标高度（控制更新频率）
            if (Math.random() < 0.2) {
                updateTargetHeights();
            }
            
            updateBarHeights();
            drawBars();
            requestAnimationFrame(animate);
        }

        // 启动动画
        animate();

        // 响应窗口大小（可选）
        window.addEventListener('resize', () => {
            // 简单适配：按比例缩放Canvas
            const scale = Math.min(window.innerWidth / CANVAS_WIDTH, window.innerHeight / CANVAS_HEIGHT);
            canvas.style.width = `${CANVAS_WIDTH * scale}px`;
            canvas.style.height = `${CANVAS_HEIGHT * scale}px`;
        });
        
        // 触发一次窗口大小适配
        window.dispatchEvent(new Event('resize'));
    </script>
</body>
</html>
```

```ts
// 示例：对接麦克风音频（需用户授权）
async function connectMicrophone() {
    const audioContext = new AudioContext();
    const analyser = audioContext.createAnalyser();
    analyser.fftSize = 128; // FFT大小，决定频谱精度
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);

    // 获取麦克风权限
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const source = audioContext.createMediaStreamSource(stream);
    source.connect(analyser);

    // 替换原有的随机高度更新逻辑
    function updateFromMic() {
        analyser.getByteFrequencyData(dataArray);
        for (let i = 0; i < barCount; i++) {
            // 将音频数据映射到柱体高度
            const index = Math.floor(i * bufferLength / barCount);
            targetHeights[i] = dataArray[index] / 255 * (CANVAS_HEIGHT - 40);
        }
    }

    // 在动画循环中调用
    function animateWithMic() {
        updateFromMic();
        updateBarHeights();
        drawBars();
        requestAnimationFrame(animateWithMic);
    }
    animateWithMic();
}

// 点击页面启动麦克风（需用户交互触发）
canvas.addEventListener('click', () => {
    connectMicrophone().catch(err => console.error('麦克风授权失败：', err));
});
```