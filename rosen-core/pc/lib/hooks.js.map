{"version":3,"file":"hooks.js","sourceRoot":"","sources":["../core/hooks.ts"],"names":[],"mappings":";AAAA,OAAO,KAAK,MAAM,OAAO,CAAC;AAC1B,OAAO,EAAE,WAAW,EAAE,WAAW,EAAE,MAAM,aAAa,CAAC;AAKvD,MAAM,UAAU,UAAU,CAAC,UAA6B;IAA7B,2BAAA,EAAA,qBAA6B;IACpD,OAAO,WAAW,CAAC,UAAC,KAAY,IAAK,OAAA,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,EAA7B,CAA6B,CAAC,CAAC;AACxE,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,SAAS,CAAgE,aAAwC;IAAE,cAAU;SAAV,UAAU,EAAV,qBAAU,EAAV,IAAU;QAAV,6BAAU;;IACzI,IAAM,QAAQ,GAAG,WAAW,EAAE,CAAC;IAC/B,OAAO,KAAK,CAAC,WAAW,CAAC,cAAM,OAAA,QAAQ,CAAC,aAAa,wCAAI,IAAI,WAAE,EAAhC,CAAgC,EAAE,IAAI,CAAC,CAAC;AAC3E,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,cAAc,CAC1B,aAAgF;IAChF,cAAU;SAAV,UAAU,EAAV,qBAAU,EAAV,IAAU;QAAV,6BAAU;;IAEV,IAAM,QAAQ,GAAG,WAAW,EAAE,CAAC;IAC/B,OAAO,KAAK,CAAC,WAAW,CAAC,UAAC,GAAM,IAAK,OAAA,QAAQ,CAAC,aAAa,sDAAI,IAAI,YAAE,GAAG,WAAE,EAArC,CAAqC,EAAE,IAAI,CAAC,CAAC;AACtF,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,eAAe,CAC3B,aAAsF;IACtF,cAAU;SAAV,UAAU,EAAV,qBAAU,EAAV,IAAU;QAAV,6BAAU;;IAEV,IAAM,QAAQ,GAAG,WAAW,EAAE,CAAC;IAC/B,OAAO,KAAK,CAAC,WAAW,CAAC,UAAC,IAAO,EAAE,IAAO,IAAK,OAAA,QAAQ,CAAC,aAAa,sDAAI,IAAI,YAAE,IAAI,EAAE,IAAI,WAAE,EAA5C,CAA4C,EAAE,IAAI,CAAC,CAAC;AACvG,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,kBAAkB,CAAsC,aAAsC,EAAE,SAAY;IACxH,IAAM,QAAQ,GAAG,WAAW,EAAE,CAAC;IAC/B,OAAO,KAAK,CAAC,WAAW,CAAC,UAAC,WAAiB;;QAAK,OAAA,QAAQ,CAAC,aAAa,CAAC,CAAA,SAAE,GAAC,SAAS,IAAG,WAAW,IAAO,CAAA,CAAC,CAAC;IAA1D,CAA0D,EAAE,CAAC,QAAQ,EAAE,aAAa,EAAE,SAAS,CAAC,CAAC,CAAC;AACtJ,CAAC","sourcesContent":["import React from \"react\";\r\nimport { useDispatch, useSelector } from \"react-redux\";\r\nimport { Action, State } from \"./reducer\";\r\n\r\ntype DeferLiteralArrayCheck<T> = T extends Array<string | number | boolean | null | undefined> ? T : never;\r\n\r\nexport function useLoading(identifier: string = \"global\"): boolean {\r\n    return useSelector((state: State) => state.loading[identifier] > 0);\r\n}\r\n\r\n/**\r\n * Action parameters must be of primitive types, so that the dependency check can work well.\r\n * No need add dispatch to dep list, because it is always fixed.\r\n */\r\nexport function useAction<P extends Array<string | number | boolean | null | undefined>>(actionCreator: (...args: P) => Action<P>, ...deps: P): () => void {\r\n    const dispatch = useDispatch();\r\n    return React.useCallback(() => dispatch(actionCreator(...deps)), deps);\r\n}\r\n\r\n/**\r\n * For actions like:\r\n * *foo(a: number, b: string, c: boolean)\r\n *\r\n * useUnaryAction(foo, 100, \"\") will return:\r\n * (c: boolean) => void;\r\n */\r\nexport function useUnaryAction<P extends any[], U>(\r\n    actionCreator: (...args: [...P, U]) => Action<[...DeferLiteralArrayCheck<P>, U]>,\r\n    ...deps: P\r\n): (arg: U) => void {\r\n    const dispatch = useDispatch();\r\n    return React.useCallback((arg: U) => dispatch(actionCreator(...deps, arg)), deps);\r\n}\r\n\r\n/**\r\n * For actions like:\r\n * *foo(a: number, b: string, c: boolean)\r\n *\r\n * useBinaryAction(foo, 100) will return:\r\n * (b: string, c: boolean) => void;\r\n */\r\nexport function useBinaryAction<P extends any[], U, K>(\r\n    actionCreator: (...args: [...P, U, K]) => Action<[...DeferLiteralArrayCheck<P>, U, K]>,\r\n    ...deps: P\r\n): (arg1: U, arg2: K) => void {\r\n    const dispatch = useDispatch();\r\n    return React.useCallback((arg1: U, arg2: K) => dispatch(actionCreator(...deps, arg1, arg2)), deps);\r\n}\r\n\r\n/**\r\n * For actions like:\r\n * *foo(data: {key: number})\r\n *\r\n * useModuleObjectAction(foo, \"key\") will return:\r\n * (objectValue: number) => void;\r\n */\r\nexport function useObjectKeyAction<T extends object, K extends keyof T>(actionCreator: (arg: T) => Action<[T]>, objectKey: K): (objectValue: T[K]) => void {\r\n    const dispatch = useDispatch();\r\n    return React.useCallback((objectValue: T[K]) => dispatch(actionCreator({ [objectKey]: objectValue } as T)), [dispatch, actionCreator, objectKey]);\r\n}\r\n"]}